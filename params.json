{"name":"Biggy","tagline":"A Fast, In-Memory Document/Relational Query Tool for .NET","body":"## Biggy - A Fast, Syncronized Document/RElational Query Tool for .NET\r\n\r\n### Note: Biggy is in PRE-RELEASE. Expect things to change, and use in production at your own risk!\r\n\r\nThis project started life as an implementation of `ICollection` that persisted itself to a file using JSON seriliazation. That quickly evolved into using Postgres as a JSON store, and then a host of other data stores. What we ended up with is the fastest data tool you can use.\r\n\r\nData is loaded into memory when your application starts, and you query it with Linq. That's it. It loads incredibly fast (100,000 records in about 1 second) and from there will sync your in-memory list with whatever store you choose.\r\n\r\nOut of the box, Biggy supports [PostgreSql](http://www.postgresql.org/) and [SQLite](http://www.sqlite.org/), as well as persistence to simple file-based JSON storage. However, Biggy is designed to be extensible, and you can use the `IDataStore` interface to support any other store you need.\r\n\r\nWhat Biggy does is represent an `ICollection` over your datastore. You define your store, and inject the store into the list at initialization.\r\n\r\n## File-Based JSON Store\r\n\r\nAt the simplest level, Biggy can be used against a simple JSON file. The performance of the JSON Store is lickety-split fast.\r\n\r\n```csharp\r\npublic partial class Artist {\r\n  public int ArtistId { get; set; }\r\n  public string Name { get; set; }\r\n}\r\n  \r\nvar store = new JsonStore<Artist>();\r\nvar artists = new BiggyList<Artist>(store);\r\n\r\nartists.Add(new Artist { ArtistId = 1, Name = \"The Wipers\" });\r\nartists.Add(new Artist { ArtistId = 2, Name = \"The Fastbacks\" });\r\n\r\nforeach(var artist in artists) { \r\n  Console.WriteLine(\"Id: {0} Name: {1}\", artist.ArtistId, artist.Name);\r\n}\r\n\r\n```\r\n\r\nThe above code will do a number of things:\r\n\r\n - Creates a file named \"artists.json\" in a default directory in your project root named \"Data.\"\r\n - Add each artist to the ICollection implementation `artists` as well as to the file artists.json.\r\n \r\nIf we go to the ../../Data folder, we find artists.json:\r\n \r\n```js\r\n[{\"ArtistId\":1,\"Name\":\"The Wipers\"},{\"ArtistId\":2,\"Name\":\"The Fastbacks\"}]\r\n```\r\n\r\nWhen Biggy loads the data it deserializes it from the backing store and you can access it just like any `ICollection<T>`. Similarly, Modifications to the items in the `ICollection` are persisted back into the backing store. \r\n\r\n## Complex Documents\r\n\r\nAbove we saw a couple very simple documents stored as a JSON file. We could just as easily work with a more complex object:\r\n\r\n```csharp\r\npublic class ArtistDocument {\r\n  public ArtistDocument() {\r\n    this.Albums = new List<Album>();\r\n  }\r\n  public int ArtistDocumentId { get; set; }\r\n  public string Name { get; set; }\r\n  public List<Album> Albums;\r\n}\r\n  \r\npublic partial class Album {\r\n  public Album() {\r\n    //this.Tracks = new HashSet<Track>();\r\n  }\r\n  public int AlbumId { get; set; }\r\n  public string Title { get; set; }\r\n  public int ArtistId { get; set; }\r\n}\r\n```\r\n\r\nHere, we might use another JSON store with our `BiggyList`:\r\n```csharp\r\n  //this will create a Data/artistdocuments.json file in your project/site root:\r\n  var newArtist = new ArtistDocument { ArtistDocumentId = 3, Name = \"Nirvana\" };\r\n  newArtist.Albums.Add(new Album { AlbumId = 1, ArtistId = 3, Title = \"Bleach\" });\r\n  newArtist.Albums.Add(new Album { AlbumId = 2, ArtistId = 3, Title = \"Incesticide\" });\r\n\r\n```\r\nHere, we created an artist document, and nested a couple of albums in the `Albums` property. This is persisted to our JSON store in a file named artistdocuments.json like so:\r\n\r\n```js\r\n[{\"Albums\":[{\"AlbumId\":1,\"Title\":\"Bleach\",\"ArtistId\":3},\r\n{\"AlbumId\":2,\"Title\":\"Incesticide\",\"ArtistId\":3}],\r\n\"ArtistDocumentId\":3,\"Name\":\"Nirvana\"}]\r\n```\r\n\r\nYou can query using LINQ:\r\n\r\n```csharp\r\n\r\n// This immediately load any existing artist documents from the json file:\r\nvar artists = new BiggyList<ArtistDocument>(store);\r\n\r\n// This query never hits the disk - it uses LINQ directly in memory:\r\nvar someArtist = artists.FirstOrDefault(a => a.Name == \"Nirvana\");\r\nvar someAlbum = someArtist.Albums.FirstOrDefault(a => a.Title.Contains(\"Incest\"));\r\n\r\n// Update:\r\nsomeAlbum.Title = \"In Utero\";\r\n\r\n//this writes to disk in a single flush - so it's fast too\r\nartists.Update(someArtist);\r\n```\r\n\r\n## Relational Database Engines\r\nIf your needs grow beyond storage to a flat JSON file, you can easily use SQLite or Postgres as a backing store for **both document structures and standard relational table data.** \r\n\r\nIf we use `pgDocumentStore` or `sqliteDocumentstore`, our objects are serialilzed into JSON and stored in the `body` field of a record. \r\n\r\nif we use `pgRelationalStore` or `sqliteRelationalStore`, data is read/written to the source table as we would expect. \r\n\r\nOur primary relational store of choice is, and has been, Postgresql. Not only is Postgres an amzing database, it has a JSON datatype right out of the box, which lends itself easily to the document storage aspects of Biggy. \r\n\r\nIn between the flat JSON file and a full-blown Posgres install is SQLite. SQLite is a file-based local relational storate option offering some really nice performance characteristics. \r\n\r\nBest part for both, they are FREE, cross-platform, and open source. \r\n\r\n## SQLite\r\nUsing SQLite with Biggy is almost as simple as using a flat JSON file:\r\n\r\n```csharp\r\n      // This will create a new SQLite database file named \"TestDb.db in ../../Data\r\n      // if a database file b y that name doesn;t already exist:\r\n      var store = new sqliteDocumentStore<ArtistDocument>(\"TestDb\");\r\n\r\n      // This will create a table named artistdocuments in TestDb if one doesn't already exist:\r\n      var artistDocs = new BiggyList<ArtistDocument>(store);\r\n\r\n      var newArtist = new ArtistDocument { ArtistDocumentId = 1, Name = \"Metallica\" };\r\n      newArtist.Albums.Add(new Album { AlbumId = 1, ArtistId = newArtist.ArtistDocumentId, Title = \"Kill 'Em All\" });\r\n      newArtist.Albums.Add(new Album { AlbumId = 2, ArtistId = newArtist.ArtistDocumentId, Title = \"Ride the Lightning\" });\r\n\r\n      // This will add a record to the artistdocuments table:\r\n      artistDocs.Add(newArtist);\r\n```\r\n\r\nThe code above will create a SQLite database file named `TestDb.db` in our <Project Root>/Data directory if a db by that name does not already exist, and then also create a table named artistdocuments (again, if one doesn't already exist). \r\n\r\n## Get All Relational With It...\r\nBiggy works with relational data too. When we want to read/write standard relational data, we use the `RelationalStore` implementation instead of `DocumentStore`. \r\n\r\nWe could pull down the SQLite version of [Chinook Database](http://chinookdatabase.codeplex.com/), drop it in our ../../Data directory, and work with some ready-to-use sample data to do some fancy querying with LINQ:\r\n\r\n```csharp\r\nvar artistStore = new sqliteRelationalStore<Artist>(\"Chinook\");\r\nvar albumStore = new sqliteRelationalStore<Album>(\"Chinook\");\r\n\r\n// Loads all data from the Artist table into memory:\r\nvar artists = new BiggyList<Artist>(artistStore);\r\n\r\n// Loads all data from the Album table into memory:\r\nvar albums = new BiggyList<Album>(albumStore);\r\n\r\n// Find all the albums by a particular artist using LINQ:\r\nvar artistAlbums = from a in albums\r\n                    join ar in artists on a.ArtistId equals ar.ArtistId\r\n                    where ar.Name == \"AC/DC\"\r\n                    select a;\r\n```\r\n\r\n## Postgresql\r\nAll of the above works with Postgres as well, except that Postgres, of course, doesn't store files in your project. \r\n\r\nIf we want to use Biggy with a Postgres store, all we need to do is pass it the name of the connection string as defined in the `App.config` or `Web.config` file in our project.\r\n\r\n### Define a connection string in App.config:\r\n```xml\r\n<configuration>\r\n  <startup>\r\n    <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.0\"/>\r\n  </startup>\r\n  <connectionStrings>\r\n    <add name=\"chinook-pg\" connectionString=\"server=localhost;user id=biggy;password=password;database=chinook\"/>\r\n  </connectionStrings>\r\n</configuration>\r\n```\r\nNow, assuming we have the Chinook Database for Postgres defined in our PG database, we can do the following:\r\n```csharp\r\nvar artistStore = new pgRelationalStore<Artist>(\"chinook-pg\");\r\nvar albumStore = new pgRelationalStore<Album>(\"chinook-pg\");\r\nvar trackStore = new pgRelationalStore<Track>(\"chinook-pg\");\r\n\r\n// Loads all data from the Artist table into memory:\r\nvar artists = new BiggyList<Artist>(artistStore);\r\n\r\n// Loads all data from the Album table into memory:\r\nvar albums = new BiggyList<Album>(albumStore);\r\n\r\n// Loads all data from the Album table into memory:\r\nvar tracks = new BiggyList<Track>(trackStore);\r\n\r\n\r\n// Find all the tracks by a particular artist using LINQ:\r\nvar artistTracks = (from t in tracks\r\n                    join al in albums on t.AlbumId equals al.AlbumId\r\n                    join ar in artists on al.ArtistId equals ar.ArtistId\r\n                    where ar.Name == \"Black Sabbath\"\r\n                    select t).ToList();\r\n```\r\n## Cache Schema Info\r\n\r\nOf course, the idea behind Biggy is to load data in memory once, and then read/write away as your application needs. The only time Biggy hits the disk is during Writes, which makes things extremely fast (the tripe-joined LINQ query above returns in a less than 5 milliseconds). \r\n\r\nBiggy works against standard relational tables by reading and caching schema info. Instead of doing this three times like we did above, we can use the `DBCore` object, and load all that once, during initialization. Then we can inject each store into our separate BiggyLists, and all reference the same schema info:\r\n\r\n```csharp\r\n// Loads and caches connection and schema info needed for all tables and columns\r\nvar _db = new pgDbCore(\"chinook-pg\");\r\n\r\nvar artists = new BiggyList<Artist>(_db.CreateRelationalStoreFor<Artist>());\r\nvar albums = new BiggyList<Album>(_db.CreateRelationalStoreFor<Album>());\r\nvar tracks = new BiggyList<Track>(_db.CreateRelationalStoreFor<Track>());\r\n\r\n\r\n// Find all the tracks by a particular artist using LINQ:\r\nvar artistTracks = (from t in tracks\r\n                    join al in albums on t.AlbumId equals al.AlbumId\r\n                    join ar in artists on al.ArtistId equals ar.ArtistId\r\n                    where ar.Name == \"Black Sabbath\"\r\n                    select t).ToList();\r\n```\r\n\r\n\r\n## What It's Good For\r\n\r\nA document-centric, \"NoSQL\"-style of development is great for high-read, quick changing things. Products, Customers, Promotions and Coupons - these things get read from the database continually and it's sort of silly. Querying in-memory makes perfect sense for this use case. For these you could use one of the document storage ideas above.could \r\n\r\nA relational, write-oriented transactional situation is great for \"slowly changing over time\" records - like Orders, Invoices, SecurityLogs, etc. For this you could use a regular relational table using the PGTable or SQLServerTable as you see fit.\r\n\r\n## Strategies\r\n\r\n . . . This section will be updated shortly . . .\r\n\r\n\r\n## A Note on Speed and Memory\r\n\r\nSome applications have a ton of data and for that, Biggy might not be the best fit if you need to read from that ton of data consistently. We've focused on prying apart data into two camps: High Read, and High Write.\r\n\r\nWe're still solidifying our benchmarks, but in-memory read is about as fast as you can get. Our writes are getting there too - currently we can drop 100,000 documents to disk in about 2 seconds - which isn't so bad. We can write 10,000 records to Postgres and SQL Server in about 500ms - again not bad.\r\n\r\nSo if you want to log with Biggy - go for it! Just understand that if you use a `DBList<T>`, it assumes you want to read too so it will store the contents in memory as well as on disk. If you don't need this, just use a `DBTable<T>` (Postgres or SQLServer) and write your heart out.\r\n\r\nYou might also wonder about memory use. Since you're storing everything in memory - for a small web app this might be a concern. Currently the smallest, free sites on Azure allow you 1G RAM. Is this enough space for your data? [Borrowing from Karl Seguin](http://openmymind.net/redis.pdf):\r\n\r\n> I do feel that some developers have lost touch with how little space data can take. The Complete Works of William\r\nShakespeare takes roughly 5.5MB of storage\r\n\r\nThe entire customer, catalog, logging, and sales history of Tekpub was around 6MB. If you're bumping up against your data limit - just move from an in-memory list to a regular table object (as shown above) and you're good to go.\r\n\r\n\r\n## Wanna Help?\r\n\r\nPlease do! Here's what we ask of you:\r\n\r\n - If you've found a bug, please log it in the Issue list. \r\n - If you want to fork and fix (thanks!) - please fork then open a branch on your fork specifically for this issue. Give it a nice name.\r\n - Make the fix and then in your final commit message please use the Github magic syntax (\"Closes #X\" or Fixes etc) so we can tie your PR to you and your issue\r\n - Please please please verify your bug or issue with a test (we use NUnit and it's simple to get going)\r\n\r\nThanks so much!\r\n\r\n\r\n### Authors\r\n\r\nThe concepts underlying Biggy were originally created by Rob Conery (@robconery) in February 2014. John Atten (@xivSolutions) joined the project early on that same month, and has since assumed responsibility for the project. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}